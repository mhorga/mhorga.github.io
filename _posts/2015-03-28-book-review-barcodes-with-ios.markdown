---
published: true
title: Book review, Barcodes with iOS
layout: post
---
Recently I had the pleasure of reading __Oliver Drobnik’s__ new title __Barcodes with iOS__ so here I am today, eager to start writing a review for it. Once I started reading the book, I realized I know little about barcodes, their evolution, or how to write an application that uses them. The more I was reading, the more I was attracted by this topic and I could not stop reading the book until I finished it.

Oliver is first taking us into a gentle history of the evolution of barcodes. In the first chapter we learn what is the difference between standards such as UPC, EAN, GTIN, Code 25, Code 39, Code 93, and Code 128. Fortunately, Apple also opened the access to the barcode API starting with iOS 7 so it is now a great opportunity for developers to learn how to leverage this knowledge.

The second chapter is introducing us to media capture in AV Foundation, how video frames flow through the AV Foundation components to a preview layer, configuring cameras and toggling device features, implementing autofocus and tap-to-focus, capturing still images and handling UI rotation. We will learn step-by-step how to build a camera app that includes all the features above. At the end of the chapter we are challenged to enhance our app with a couple of advanced extra features.

The third chapter shows us how to scan barcodes with AV Foundation’s metadata detector, tells us about optimizing scanning performance and user experience, about UI considerations for different kinds of barcode-scanning scenarios, and about navigating around common barcode-scanning pitfalls. It is now time to add a barcode detector to the camera app that we started in the second chapter. By building a QR code scanner we will learn how to plug a metadata output into our AV Foundation video pipeline.

In the fourth chapter we see why barcodes is one of the technologies that makes Apple’s Passbook system possible, we read about micro-documents as a convenient digital alternative to paper tickets and plastic cards, we learn about creating Passbook tickets with Ruby, and see a method for validating Passbook tickets without a server. We get an understanding of how to create signed Passbook passed, and then we create a verification app that checks these passes. Armed with this knowledge we could even come up with our own usage patterns.

The fifth chapter tells us about the producing of 2D barcodes for display and print with Core Image, about the printing sheets of barcodes with AirPrint, about saving paper with the AirPrint Printer Simulator, about generating 1D barcodes with BarCodeKit, and about printing to AirPrint roll-feed printers. When we finish our QR Code Builder app we will be able to enter a website URL into a text field, generate a QR Code as the characters are input and display a live preview, adjust the error-correction level with a slider, copy the image to the pasteboard with a long-press gesture, and print the configured QR Code to a sheet of stickers.

In the sixth chapter we learn about modern networking with NSURLSession, about updating Core Data database asynchronously, about presenting a barcode scanner modally and by using unwind segues, about calling RESTful web services, and about unit testing the web service wrappers. At this time our app should be able to use barcode scanning to let a user add music media to a collection using Core Data and to display the music collection in a table list view. We were also able to create a convenient wrapper class around the web service API.

In the last chapter of the book, we build a YardSale app that will feature a list of currently active yard sale locations and show them on a map. If a user taps on one of the location pins, they’ll see the sale’s name in a callout bubble. Tapping on the callout accessory will show the in-store UI for this yard sale. The user can easily “leave” the store by tapping a Close button. If the app is inactive and the user walks into the vicinity of a yard sale, they will get a notification about the sale. When the app is active or becomes active because of the user tapping on the notification action, the in-store UI will also be shown. The in-store UI shows a list of products grouped by the table they’re on. If an iBeacon is received more strongly than any others, only the table associated with this beacon is shown. The in-store UI displays a button allowing the user to scan a barcode on an item for sale, and after scanning an alert will show the layers of context.

What I liked as an iOS developer was that there is a lot of detailed (even step-by-step) information about building iOS apps using barcodes. As a casual reader interested only in knowing how barcodes work however, one could say the information is over abundant and goes too deep into the topic, at times losing the abstract side of the topic. Nonetheless, you will find that the book also offers great insights about adjacent topics such as calling RESTful APIs, or dealing with iBeacons and Passbook. For the reader category other than a developer I recommend reading other books about barcodes, otherwise this is your go-to book. Now that we have learned everything about barcodes, Oliver suggests that we can rightfully claim the title of “iOS Barcode Guru”, with whom I agree wholeheartedly. I suggest you don’t wait any longer and head over to the [Amazon](http://www.amazon.com/dp/161729215X) or the [Manning](http://www.manning.com/drobnik/) web site and get the book right away. You will not regret your decision.
